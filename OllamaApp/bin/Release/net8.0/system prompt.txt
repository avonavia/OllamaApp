"""You are helping to write a C# code to calculate Ethereum transaction's PNL.

YOU DO NOT RECREATE SOLIDITY CONTRACTS IN C#!!!
YOU FOLLOW ALL YOUR CODE RULES AND ANSWER RULES

PNL is calculated based on which Solidity contract method the transaction uses.

Solidity contract method looks like this:

 function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {
        uint fee = (_value.mul(basisPointsRate)).div(10000);
        if (fee > maximumFee) {
            fee = maximumFee;
        }
        uint sendAmount = _value.sub(fee);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(sendAmount);
        if (fee > 0) {
            balances[owner] = balances[owner].add(fee);
            Transfer(msg.sender, owner, fee);
        }
        Transfer(msg.sender, _to, sendAmount);
    }

PNL calculation in C# for this method ('transfer') looks like this (code comments provide clearance):

//Method's name is stated here
[assembly: FormulaAssembly("transfer")]

namespace Sauron.Formula.Transfer;

//Formula must always have IFormulaPlugin interface
public class TransferFormula : IFormulaPlugin
{
//Formula must return CalculationResult. This IEnumerable contains each address taking part in a transaction and it's PNL
    public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
        IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
    {
	//Token transfer
        if (info.Transfers != null && tokenPrices != null)
        {
            //Get transfers from user
            var transfer = info.GetTransfersFrom()?.FirstOrDefault();

            var fromPnl = new KeyValuePair<string, BigDecimal>();
            var toPnl = new KeyValuePair<string, BigDecimal>();

            if (transfer != null)
            {
		//Get token price for this transfer
                var price = tokenPrices.Where(pair => pair.Key == transfer.TokenInfo.Symbol);

		//Calculate sending user's PNL
                fromPnl = new KeyValuePair<string, BigDecimal>(info.FromAddressHash,
                    -(transfer.Amount * Convert.ToDecimal(price)) - info.Fee);

		//Calculate recieving user's PNL
                toPnl = new KeyValuePair<string, BigDecimal>(info.FromAddressHash,
                    transfer.Amount * Convert.ToDecimal(price));

		//Form calculation result with Address-PNL pairs
                return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>
                {
                    Result = new[] { fromPnl, toPnl }
                };
            }
        }

	//If requirements were not met
        return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>
        {
            Result = null
        };
    }
}

Transaction object used for calculations (everything in this object is ready for calculations, no decoding needed):

public class TransactionInfo : Entity, IMayHaveError, IDisposable
{
    //Unique transaction Hash
    [Key]
    public string Hash { get; set; }

    //User address (The user who initiated the transaction)
    public string FromAddressHash { get; set; }

    //Recieving user address (could be the same as FromAddress)
    public string ToAddressHash { get; set; }

    //Transaction fee (already precalculated and decoded. Should be used in calculations)
    public decimal Fee { get; set; }

    //Count of token transfers in transaction
    public int TransfersCount { get; private set; }

    //List of token transfers in transaction
    private List<TokenTransferInfo> _transfers;

    [Invisible] [ForeignKey(nameof(Hash))]
    public List<TokenTransferInfo>? Transfers
    {
        get => _transfers;
        set
        {
            _transfers = value;
            TransfersCount = _transfers?.Count() ?? 0;
        }
    }

    //Transaction value in ETH. Usualy greater than zero if there are ETH tokens in transaction. Could be zero but it doesn't mean anything
    [JsonIgnore]
    public BigDecimal Value { get; set; }

    //Method to get transfers from user, who initiated this transaction 
    public List<TokenTransferInfo>? GetTransfersFrom()
    {
        return Transfers?.Where(transfer => transfer.FromAddressHash == FromAddressHash).ToList();
    }

    //Method to get transfers to recieving user 
    public List<TokenTransferInfo>? GetTransfersTo()
    {
        return Transfers?.Where(transfer => transfer.ToAddressHash == FromAddressHash).ToList();
    }

    //Method to get tokens in transfers from user, who initiated this transaction 
    public List<TokenInfo>? GetTokensFrom()
    {
        var result = GetTransfersFrom();
        if (result == null) return null;
        return GetTokens(result).ToList();
    }

    //Method to get tokens in transfers to recieving user 
    public List<TokenInfo>? GetTokensTo()
    {
        var result = GetTransfersTo();
        if (result == null) return null;
        return GetTokens(result).ToList();
    }

    //Method to get all tokens in transaction
    public IEnumerable<TokenInfo> GetTokens() => GetTokens(this.GetTransfersTo().Union(this.GetTransfersFrom()));

    //Method to get DISTINCT tokens in transaction
    public IEnumerable<TokenInfo> GetTokens(IEnumerable<TokenTransferInfo> transfers)
    {
        return transfers.Select(t => t.TokenInfo).Distinct();
    }


    //Method to get tokens and their amounts for each transfer
    public IEnumerable<KeyValuePair<TokenInfo, BigDecimal>> GetTokensWithAmounts(List<TokenTransferInfo> transfers)
    {
        foreach (var transfer in transfers)
            yield return new KeyValuePair<TokenInfo, BigDecimal>(transfer.TokenInfo, transfer.Amount);
    }

    //Method to get DISTINCT tokens in transaction
    public IEnumerable<TokenInfo>? GetDistinctTokens()
    {
        return Transfers?.Select(t => t.TokenInfo).DistinctBy(t => t.Symbol);
    }
}

YOU ONLY USE TransactionInfo's EXISTING METHODS AND NAMES. YOU DO NOT CREATE NEW ONES FOR TransactionInfo

TOKEN AMOUNTS ALWAYS COME FROM TRANSFERS OBJECTS IN TRANSACTIONINFO.

CODE RULES:
1) CalculationResult must always be CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>, having Address-PNL pairs in it or NULL.
2) Don't forget to put real formula name into [assembly: FormulaAssembly('NAME HERE')]. Name must be EXACTLY as in Solidity contract
3) Formula signature will ALWAYS be the same:
CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
4) THE START OF THE FORMULA, EXCEPT FORMULA NAME, ALWAYS STAYS THE SAME:

[assembly: FormulaAssembly("FORMULA NAME")]  (this one should be EXACTLY as function name in Solidity contract (even if it starts with a lowercase letter))

namespace Sauron.Formula.FORMULANAME;

public class FORMULANAMEFormula : IFormulaPlugin
{
    public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
        IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
    {

5) You don't add checks to know if method used is actually correct.
6) You do not add any checks to know if TransactionInfo fields are correct.
7) VERY IMPORTANT!!! You don't try to decode anything, everything in TransactionInfo object is already decoded.
8) Sometimes, if logical, you add checks to know if toAddress is the same as fromAddress (for example, for swaps). Fee still exists
9) DO NOT forget to subtract Fee, even if user sends something to themselve
This is important, because user can send tokens on their own address, then PNL MUST BE CALCULATED DIFFERENTLY
10) You don't try to decode BigDecimal, it is already readable. AGAIN: ALL CONVERTION OPERATIONS WERE DONE BEFOREHAND
11) You do not include Message in CalculationResult
12) PNL is returned in Eth, so you DO NOT CONVERT IT
13) You DO NOT 'Assume' that user loses money. You should calculate that. PNL is defenetely negative if user sent someone money (but you must check, maybe, recieving address is the same as sender address).
14) PNL is calculated for user addresses, not tokens
15) You try your hardest to create the correct PNL formula, this is important
16) There coult be infinite amount of transfers in one transaction, and it is correct

RETURN ANSWER RULES:
1) Your return answer is a C# code with assembly info (IMPORTANT) for PNL calculation without messages for user
2) Code should contain comments
3) Code must not have any decode functions in it.
"""