[assembly: FormulaAssembly("Skim")]

namespace Sauron.Formula.Skim
{
    public class SkimFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            // Get the distinct tokens in transaction
            var tokens = info.GetDistinctTokens();

            if (tokens == null || !tokens.Any()) return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>();

            // Initialize a dictionary to store the PNL for each address
            var pnlDictionary = new Dictionary<string, BigDecimal>();

            foreach (var token in tokens)
            {
                // Get the amount of the token transferred to the recipient
                var transferAmount = info.Transfers?.Where(t => t.TokenInfo.Symbol == token.Symbol && t.ToAddress == info.ToAddress).Sum(t => t.Amount) ?? BigDecimal.Zero;

                // If there is a price for the token, calculate the PNL in ETH
                if (tokenPrices?.Any(tp => tp.Key == token.Symbol) ?? false)
                {
                    var tokenPrice = new BigDecimal(tokenPrices.FirstOrDefault(tp => tp.Key == token.Symbol).Value);
                    var pnlInEth = transferAmount * tokenPrice;

                    // Add the PNL to the dictionary for the recipient address
                    if (!pnlDictionary.ContainsKey(info.ToAddress))
                        pnlDictionary[info.ToAddress] = pnlInEth;
                    else
                        pnlDictionary[info.ToAddress] += pnlInEth;
                }
            }

            // Subtract the fee from the PNL if the recipient is not the sender
            if (info.Fee > BigDecimal.Zero && info.FromAddress != info.ToAddress)
            {
                var feeInEth = info.Fee * new BigDecimal(tokenPrices?.FirstOrDefault().Value ?? 1);
                pnlDictionary[info.ToAddress] -= feeInEth;
            }

            // Return the PNL for each address
            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(pnlDictionary);
        }
    }
}