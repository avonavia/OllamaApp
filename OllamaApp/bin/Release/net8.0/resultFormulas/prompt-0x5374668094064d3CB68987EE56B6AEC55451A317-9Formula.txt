```csharp
[assembly: FormulaAssembly("skim")]

namespace Sauron.Formula.Skim
{
    public class SkimFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            var pnl = new List<KeyValuePair<string, BigDecimal>>();

            if (info.Transfers == null || !info.Transfers.Any()) return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>>.Success(pnl);

            // If the toAddress is not specified or it's the same as fromAddress, no PNL calculation is needed
            if (string.IsNullOrEmpty(info.To) || info.From == info.To) return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>>.Success(pnl);

            // Getting distinct tokens in the transaction
            var tokens = info.GetDistinctTokens();

            if (tokens == null || !tokens.Any()) return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>>.Success(pnl);

            foreach (var token in tokens)
            {
                // Getting the transfers for this token
                var tokenTransfers = info.Transfers.Where(t => t.TokenInfo.Symbol == token.Symbol).ToList();

                // Calculating the PNL for this token
                BigDecimal totalAmountTransferred = tokenTransfers.Sum(t => t.Amount);
                if (totalAmountTransferred > 0 && tokenPrices != null)
                {
                    var tokenPrice = tokenPrices.FirstOrDefault(tp => tp.Key == token.Symbol).Value;
                    pnl.Add(new KeyValuePair<string, BigDecimal>(info.From, -totalAmountTransferred * (decimal)tokenPrice));
                }
            }

            return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>>.Success(pnl);
        }
    }
}
```