//Method to calculate PNL for given Solidity contract method "_safeTransfer"

[assembly: FormulaAssembly("SafeTransferPNL")]

namespace Sauron.Formula.SafeTransferPNL
{
    public class SafeTransferPNLFormula : IFormulaPlugin
    {
        //Calculate PNL for the transaction where tokens are transferred from one address to another
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            //Calculate total amount of tokens transferred in the transaction for each user address
            var transfersByAddress = GetTransfersGroupedByAddress(info.Transfers);

            //If there are no transfers or only one transfer (i.e., sending tokens to yourself), return null as PNL can't be calculated
            if (transfersByAddress == null || transfersByAddress.Count <= 1)
                return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(null);

            //Get token prices or use default values if not provided
            var tokenPricesDict = GetTokenPrices(tokenPrices);

            //Calculate PNL for each user address
            var pnlByAddress = transfersByAddress.Select(kv => CalculatePNLForAddress(kv, tokenPricesDict));

            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(pnlByAddress);
        }

        //Get total amount of tokens transferred for each user address
        private Dictionary<string, IEnumerable<TokenTransferInfo>> GetTransfersGroupedByAddress(List<TokenTransferInfo> transfers)
        {
            return transfers.Where(t => t.From != null && t.To != null) //Filter out invalid transfers
                           .GroupBy(t => t.From.Equals(info.UserAddress) ? t.To : t.From) //Group by user address
                           .ToDictionary(g => g.Key, g => g.AsEnumerable());
        }

        //Get token prices or use default values if not provided
        private Dictionary<string, decimal> GetTokenPrices(IEnumerable<KeyValuePair<string, decimal>>? tokenPrices)
        {
            return (tokenPrices ?? new List<KeyValuePair<string, decimal>>())
                   .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
        }

        //Calculate PNL for a single user address
        private KeyValuePair<string, BigDecimal> CalculatePNLForAddress(KeyValuePair<string, IEnumerable<TokenTransferInfo>> transfersByAddress, Dictionary<string, decimal> tokenPrices)
        {
            var pnl = BigDecimal.Zero;

            //Calculate PNL for each transfer
            foreach (var transfer in transfersByAddress.Value)
            {
                var price = GetTokenPrice(transfer.TokenInfo.Symbol, tokenPrices);
                var value = transfer.Amount * new BigDecimal((decimal)price);

                //Subtract the amount sent and add the amount received (considering fees)
                pnl -= transfer.From == info.UserAddress ? value + transfer.Fee : BigDecimal.Zero;
                pnl += transfer.To == info.UserAddress ? value - transfer.Fee : BigDecimal.Zero;
            }

            return new KeyValuePair<string, BigDecimal>(transfersByAddress.Key, pnl);
        }

        //Get token price or use a default value if not provided
        private decimal GetTokenPrice(string tokenSymbol, Dictionary<string, decimal> tokenPrices)
        {
            return tokenPrices.TryGetValue(tokenSymbol, out var price) ? price : 1m;
        }
    }
}