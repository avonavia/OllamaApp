```csharp
[assembly: FormulaAssembly("_safeTransfer")]

namespace Sauron.Formula._safeTransfer
{
    public class _safeTransferFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            if (info.Transfers == null || !info.Transfers.Any() || string.IsNullOrEmpty(info.ToAddress))
                return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>.Success(null);

            var tokenPnls = new Dictionary<string, BigDecimal>();

            foreach (var transfer in info.Transfers)
            {
                if (!tokenPnls.ContainsKey(transfer.FromAddress))
                    tokenPnls[transfer.FromAddress] = BigDecimal.Zero;

                // Subtract the transferred amount from sender's PNL
                tokenPnls[transfer.FromAddress] -= transfer.Amount;

                if (info.ToAddress != transfer.FromAddress) // Only add to recipient's PNL if they are not the same as sender
                {
                    if (!tokenPnls.ContainsKey(info.ToAddress))
                        tokenPnls[info.ToAddress] = BigDecimal.Zero;

                    // Add the transferred amount to recipient's PNL
                    tokenPnls[info.ToAddress] += transfer.Amount;
                }
            }

            // Convert token amounts to Eth and set Message to null
            var ethPnls = tokenPnls.Select(kvp => new KeyValuePair<string, BigDecimal>(kvp.Key, kvp.Value * (BigDecimal)tokenPrices?.FirstOrDefault(t => t.Key == transfer.TokenInfo.Symbol).Value ?? 0));
            return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>.Success(ethPnls);
        }
    }
}
```