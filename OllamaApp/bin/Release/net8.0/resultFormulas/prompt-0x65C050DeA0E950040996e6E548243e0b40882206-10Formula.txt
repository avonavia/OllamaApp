[assembly: FormulaAssembly("Sync")]

namespace Sauron.Formula.Sync
{
    public class SyncFormula : IFormulaPlugin
    {
        // Assuming that token0 and token1 are already defined in TransactionInfo object
        // And reserve0, reserve1 are stored in a separate data source or calculated beforehand

        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            var pnlResult = new List<KeyValuePair<string, BigDecimal>>();
            var contractAddress = info.To; // Assuming that the contract address is To in TransactionInfo object

            // Calculate PNL for token0
            var balanceToken0 = GetBalanceOfToken(info.Transfers, info.Token0);
            var pnlToken0 = (balanceToken0 * new BigDecimal(tokenPrices.FirstOrDefault(x => x.Key == info.Token0).Value)) - info.Reserve0;
            pnlResult.Add(new KeyValuePair<string, BigDecimal>(info.From, pnlToken0));

            // Calculate PNL for token1
            var balanceToken1 = GetBalanceOfToken(info.Transfers, info.Token1);
            var pnlToken1 = (balanceToken1 * new BigDecimal(tokenPrices.FirstOrDefault(x => x.Key == info.Token1).Value)) - info.Reserve1;
            pnlResult.Add(new KeyValuePair<string, BigDecimal>(info.From, pnlToken1));

            return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>.Success(pnlResult);
        }

        private BigDecimal GetBalanceOfToken(List<TokenTransferInfo> transfers, string token)
        {
            var balance = transfers.Where(t => t.TokenInfo.Symbol == token).Sum(t => t.Amount);
            return balance;
        }
    }
}