[assembly: FormulaAssembly("sync")]

namespace Sauron.Formula.sync
{
    public class syncFormula : IFormulaPlugin
    {
        // This formula calculates PNL for a Uniswap-like contract that syncs its balances with two tokens (token0 and token1)
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            // Check if Transfers object is not null and contains at least two transfers (for token0 and token1)
            if (info.Transfers == null || info.Transfers.Count < 2)
                return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(null);

            // Get balances for token0 and token1 from Transfers object
            var balanceToken0 = info.Transfers[0].Amount;
            var balanceToken1 = info.Transfers[1].Amount;

            // Calculate PNL for contract's address using token prices
            BigDecimal pnl = 0;
            if (tokenPrices != null)
            {
                var priceToken0 = tokenPrices.FirstOrDefault(p => p.Key == info.Transfers[0].TokenInfo.Symbol).Value;
                var priceToken1 = tokenPrices.FirstOrDefault(p => p.Key == info.Transfers[1].TokenInfo.Symbol).Value;

                // Check if prices for both tokens are available
                if (priceToken0 > 0 && priceToken1 > 0)
                    pnl = balanceToken0 * (decimal)priceToken0 + balanceToken1 * (decimal)priceToken1 - info.Fee;
            }

            // Return PNL for contract's address in a dictionary
            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(new[] {
                new KeyValuePair<string, BigDecimal>(info.ToAddress, pnl)
            });
        }
    }
}