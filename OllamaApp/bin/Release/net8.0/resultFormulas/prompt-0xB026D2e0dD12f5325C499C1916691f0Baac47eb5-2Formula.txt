//Assembly information is added for the formula name to match with Solidity contract
[assembly: FormulaAssembly("_safeTransfer")]

namespace Sauron.Formula._safeTransfer

//Implementing IFormulaPlugin interface for our formula
public class _safeTransferFormula : IFormulaPlugin
{
    //CalculationResult is a generic type that contains the result of the calculation as KeyValuePair<Address, PNL> pairs or null
    public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
        IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
    {
        //Initialize a dictionary to store the PNL for each address
        Dictionary<string, BigDecimal> pnlMap = new Dictionary<string, BigDecimal>();

        //Iterate over all transfers in the transaction
        foreach (var transfer in info.Transfers)
        {
            //Token price is used to calculate PNL in Eth
            decimal tokenPrice;
            if (!tokenPrices?.Any(tp => tp.Key == transfer.TokenInfo.Symbol) ?? false)
                continue;   //If the token price is not provided, we cannot calculate the PNL for this transfer
            else
                tokenPrice = tokenPrices.First(tp => tp.Key == transfer.TokenInfo.Symbol).Value;

            //Calculate PNL in Eth
            BigDecimal pnlInEth = (transfer.Amount * new BigDecimal(tokenPrice)) / new BigDecimal(1e18);  //Assuming that token decimals is 18

            //Subtract fee from the PNL, as per the code rules
            pnlInEth -= info.Fee;

            //Update the PNL for the sender address
            if (pnlMap.ContainsKey(info.FromAddress))
                pnlMap[info.FromAddress] -= pnlInEth;
            else
                pnlMap[info.FromAddress] = -pnlInEth;

            //Update the PNL for the receiver address, if it's not the same as sender address
            if (info.ToAddress != info.FromAddress)
            {
                if (pnlMap.ContainsKey(info.ToAddress))
                    pnlMap[info.ToAddress] += pnlInEth;
                else
                    pnlMap[info.ToAddress] = pnlInEth;
            }
        }

        //Return the calculation result as KeyValuePair<Address, PNL> pairs or null if no transfers were found
        return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>() { Result = pnlMap.Select(kvp => new KeyValuePair<string, BigDecimal>(kvp.Key, kvp.Value)) };
    }
}