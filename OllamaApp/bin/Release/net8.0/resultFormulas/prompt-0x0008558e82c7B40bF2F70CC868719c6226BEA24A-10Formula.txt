//Assembly name should be exactly as function name in Solidity contract (even if it starts with a lowercase letter)
[assembly: FormulaAssembly("sync")]

namespace Sauron.Formula.sync
{
    public class syncFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            //Check if necessary information is available in TransactionInfo object
            if (info.Transfers == null || tokenPrices == null || !tokenPrices.Any() || info.FromAddresses?.Count != 1)
                return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>.Failure("Invalid TransactionInfo");

            //Get the contract address (assuming it's the only fromAddress in TransactionInfo)
            var contractAddress = info.FromAddresses[0];

            //Get distinct tokens in transaction
            var tokens = info.Transfers?.Select(t => t.TokenInfo).DistinctBy(t => t.Symbol);

            //Initialize PNL dictionary with each address and their total PNL (in Ether)
            var pnlDictionary = new Dictionary<string, BigDecimal>();
            pnlDictionary[contractAddress] = 0;

            foreach (var token in tokens)
            {
                //Get token balances before and after the transaction for this contract address
                var balanceBefore = info.Transfers.Where(t => t.FromAddress == contractAddress && t.TokenInfo.Symbol == token.Symbol).Sum(t => t.Amount);
                var balanceAfter = info.Transfers.Where(t => t.ToAddress == contractAddress && t.TokenInfo.Symbol == token.Symbol).Sum(t => t.Amount);

                //Calculate PNL (Profit and Loss) for this token (in Ether)
                var tokenPrice = tokenPrices.FirstOrDefault(p => p.Key == token.Symbol).Value;
                var deltaBalance = balanceAfter - balanceBefore;
                var pnlToken = deltaBalance * new BigDecimal((decimal)tokenPrice);

                //Add or subtract PNL to/from the contract address's total PNL (in Ether)
                pnlDictionary[contractAddress] += pnlToken;
            }

            return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>.Success(pnlDictionary);
        }
    }
}