[assembly: FormulaAssembly("SafeTransferPNL")]

using Nethereum.Util;
using Sauron.Core.Models;
using Sauron.Core.Interfaces;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;

namespace Sauron.Formula.SafeTransferPNL
{
    public class SafeTransferPNLFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            var results = new List<KeyValuePair<string, BigDecimal>>();

            // If no transfers were made or the from address is not known, return empty result
            if (info.Transfers == null || string.IsNullOrEmpty(info.FromAddress))
                return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>.Success(results);

            // If token prices are available and the fee was not paid in Ether, calculate it in USD
            var feeInUSD = (tokenPrices != null && !info.Fee.Equals(BigDecimal.Zero)) ? info.Fee * tokenPrices.FirstOrDefault(p => p.Key == "ETH").Value : BigDecimal.Zero;

            // For each transfer, calculate the PNL for the user (fromAddress) and the recipient (to address)
            foreach (var transfer in info.Transfers)
            {
                var tokenPrice = (tokenPrices != null) ? tokenPrices.FirstOrDefault(p => p.Key == transfer.TokenInfo.Symbol).Value : 1M;

                // Calculate the amount of tokens transferred in USD and subtract the fee if it was paid by the user
                var transferAmountInUSD = (transfer.FromAddress == info.FromAddress) ? (transfer.Amount * tokenPrice) - feeInUSD : transfer.Amount * tokenPrice;

                // Update or add the PNL for the corresponding address
                if (!results.Any(r => r.Key == transfer.ToAddress))
                    results.Add(new KeyValuePair<string, BigDecimal>(transfer.ToAddress, transferAmountInUSD));
                else
                    results[results.FindIndex(r => r.Key == transfer.ToAddress)] = new KeyValuePair<string, BigDecimal>(transfer.ToAddress, results.FirstOrDefault(r => r.Key == transfer.ToAddress).Value + transferAmountInUSD);
            }

            // Subtract the fee from the user's PNL if it was not already done above
            var userResultIndex = results.FindIndex(r => r.Key == info.FromAddress);
            if (userResultIndex != -1 && !feeInUSD.Equals(BigDecimal.Zero))
                results[userResultIndex] = new KeyValuePair<string, BigDecimal>(info.FromAddress, results[userResultIndex].Value - feeInUSD);

            // If the user's PNL is not in the result list (e.g. they only received tokens), add it with a PNL of 0
            if (!results.Any(r => r.Key == info.FromAddress))
                results.Add(new KeyValuePair<string, BigDecimal>(info.FromAddress, BigDecimal.Zero));

            return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>.Success(results);
        }
    }
}