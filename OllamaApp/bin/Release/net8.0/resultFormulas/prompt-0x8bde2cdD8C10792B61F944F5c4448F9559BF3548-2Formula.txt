```csharp
[assembly: FormulaAssembly("SafeTransfer")]

namespace Sauron.Formula.SafeTransfer
{
    public class SafeTransferFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            var results = new List<KeyValuePair<string, BigDecimal>>();

            // Loop through each transfer in the transaction
            foreach (var transfer in info.Transfers)
            {
                if(transfer.To == info.FromAddress)
                    continue; // Skip transfers to self

                var tokenPrice = GetTokenPrice(tokenPrices, transfer.TokenInfo.Symbol);
                var ethAmount = (tokenPrice != null) ? BigDecimal.Multiply(transfer.Amount, new BigDecimal((decimal)tokenPrice)) : BigDecimal.Zero;

                // Subtract fee from the PNL
                ethAmount -= info.FeeInEth;

                var userAddressResult = results.FirstOrDefault(x => x.Key == info.FromAddress);

                if (userAddressResult.Value != null)
                {
                    // If the address already exists in the results, update its PNL
                    userAddressResult = new KeyValuePair<string, BigDecimal>(userAddressResult.Key, BigDecimal.Subtract(userAddressResult.Value, ethAmount));
                    results[results.IndexOf(userAddressResult)] = userAddressResult; // Update the result in the list
                }
                else
                {
                    // If the address does not exist in the results, add it with its PNL
                    results.Add(new KeyValuePair<string, BigDecimal>(info.FromAddress, BigDecimal.Negate(ethAmount)));
                }
            }

            return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>.Success(results);
        }

        private decimal? GetTokenPrice(IEnumerable<KeyValuePair<string, decimal>>? tokenPrices, string symbol)
        {
            if (tokenPrices == null) return null;

            var price = tokenPrices.FirstOrDefault(x => x.Key == symbol).Value;

            return price > 0 ? price : (decimal?)null;
        }
    }
}
```