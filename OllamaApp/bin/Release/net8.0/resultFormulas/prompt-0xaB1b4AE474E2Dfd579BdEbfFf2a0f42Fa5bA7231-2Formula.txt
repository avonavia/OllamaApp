// Method to calculate PNL for _safeTransfer Solidity contract method
   [assembly: FormulaAssembly("SafeTransfer")]

   namespace Sauron.Formula.SafeTransfer
   {
       public class SafeTransferFormula : IFormulaPlugin
       {
           public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
               IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
           {
               // Create a dictionary to store user addresses and their corresponding PNL values
               Dictionary<string, BigDecimal> pnlValues = new Dictionary<string, BigDecimal>();

               foreach (var transfer in info.Transfers)
               {
                   // If transfer is to self address then continue as no PNL will be calculated for it
                   if (transfer.ToAddress == info.FromAddress)
                       continue;

                   // Calculate the amount of tokens transferred in Eth by multiplying with token price
                   BigDecimal ethAmount = transfer.Amount * new BigDecimal((decimal)tokenPrices?.FirstOrDefault(x => x.Key == transfer.TokenInfo.Symbol).Value ?? 0);

                   // Subtract the fee from the total amount transferred in Eth to get the net PNL for the user
                   ethAmount -= info.Fee;

                   // Add or update the user's PNL value in the dictionary
                   if (pnlValues.ContainsKey(info.FromAddress))
                       pnlValues[info.FromAddress] += ethAmount;
                   else
                       pnlValues[info.FromAddress] = ethAmount;
               }

               // Convert the dictionary to a list of key-value pairs and return as calculation result
               var results = pnlValues.Select(x => new KeyValuePair<string, BigDecimal>(x.Key, x.Value)).ToList();
               return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(results);
           }
       }
   }