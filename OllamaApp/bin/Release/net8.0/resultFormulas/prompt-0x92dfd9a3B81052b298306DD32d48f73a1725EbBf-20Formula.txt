//Method to get unique addresses from transaction's transfers (except for the old owner)
    public IEnumerable<string>? GetUniqueAddresses(string oldOwner)
    {
        var distinctAddresses = Transfers?.SelectMany(t => new[] { t.From, t.To })
            .Where(a => a != oldOwner) // exclude the old owner address
            .Distinct();
        return distinctAddresses;
    }

    //Formula for calculating PNL when ownership is transferred in a transaction
    public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
    {
        string oldOwnerAddress = "OLD_OWNER_ADDRESS"; // Replace with the actual address of the old owner
        var uniqueAddresses = GetUniqueAddresses(oldOwnerAddress);

        if (uniqueAddresses == null)
            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(null, "No unique addresses found in transaction");

        Dictionary<string, BigDecimal> pnlByAddress = new(); // To store PNL for each address

        foreach (var address in uniqueAddresses)
        {
            var transfersToAddress = info.Transfers?.Where(t => t.To == address);
            var transfersFromAddress = info.Transfers?.Where(t => t.From == address);

            BigDecimal totalReceivedValue = GetTotalTokenValue(transfersToAddress, tokenPrices);
            BigDecimal totalSentValue = GetTotalTokenValue(transfersFromAddress, tokenPrices) + (address == info.From ? info.Fee : 0); // Subtract fee if the address is transaction sender

            pnlByAddress[address] = totalReceivedValue - totalSentValue;
        }

        return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(pnlByAddress.Select(kvp => new KeyValuePair<string, BigDecimal>(kvp.Key, kvp.Value)));
    }

    //Method to calculate the total value of tokens for a given set of transfers
    private BigDecimal GetTotalTokenValue(IEnumerable<TokenTransferInfo>? transfers, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices)
    {
        if (transfers == null || tokenPrices == null)
            return 0;

        var totalValue = transfers.Sum(t => t.Amount * GetTokenPrice(t.TokenInfo.Symbol, tokenPrices));
        return totalValue;
    }

    //Method to get the price of a given token symbol from the provided list of token prices
    private decimal GetTokenPrice(string tokenSymbol, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices)
    {
        var price = tokenPrices?.FirstOrDefault(p => p.Key == tokenSymbol).Value;
        return price ?? 0; // Return 0 if the token price is not found in the list
    }