```csharp
[assembly: FormulaAssembly("SafeTransfer")]

namespace Sauron.Formula.SafeTransfer
{
    public class SafeTransferFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            if (info?.Transfers == null || !tokenPrices.Any())
                return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>
                    (null, "Invalid transaction information or token prices.");

            var pnl = new Dictionary<string, BigDecimal>();

            foreach (var address in info.GetDistinctAddresses())
            {
                var tokensWithAmounts = GetTokensWithAmounts(info.Transfers).Where(t => t.Key.Symbol == "TOKEN"); // replace TOKEN with the actual token symbol

                foreach (var tokenInfo in tokensWithAmounts)
                {
                    var amountInEth = tokenInfo.Value * new BigDecimal((decimal)tokenPrices.First(t => t.Key == "TOKEN").Value); // convert token amount to Eth

                    if (!pnl.ContainsKey(address))
                        pnl[address] = 0;

                    if (info.FromAddress == address && info.ToAddress != address) // outgoing transaction
                        pnl[address] -= amountInEth + info.Fee; // subtract fee from PNL
                    else if (info.ToAddress == address && info.FromAddress != address) // incoming transaction
                        pnl[address] += amountInEth - info.Fee; // add to PNL and subtract fee
                }
            }

            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>
                (pnl.Select(kvp => new KeyValuePair<string, BigDecimal>(kvp.Key, kvp.Value)));
        }
    }
}
```