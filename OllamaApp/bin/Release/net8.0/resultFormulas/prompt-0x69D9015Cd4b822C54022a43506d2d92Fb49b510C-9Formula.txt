```csharp
[assembly: FormulaAssembly("skim")]

namespace Sauron.Formula.Skim
{
    public class SkimFormula : IFormulaPlugin
    {
        // Calculates PNL for skim transaction
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            if (info.Transfers == null || !info.Transfers.Any())
                return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(null);

            var pnlDictionary = new Dictionary<string, BigDecimal>();

            foreach (var transfer in info.Transfers)
            {
                // If this address is the receiver of tokens, we add the PNL
                if(transfer.To == info.FromAddress || transfer.To == info.ToAddress)
                {
                    BigDecimal pnl;
                    if (pnlDictionary.ContainsKey(transfer.TokenInfo.Symbol))
                        pnl = pnlDictionary[transfer.TokenInfo.Symbol] + transfer.Amount;
                    else
                        pnl = transfer.Amount;
                    // Subtract fee if the receiver is not the same as the sender
                    if (info.FromAddress != info.ToAddress)
                        pnl -= info.Fee;
                    pnlDictionary[transfer.TokenInfo.Symbol] = pnl;
                }
                // If this address is the sender of tokens, we subtract the PNL
                else if(transfer.From == info.FromAddress)
                {
                    BigDecimal pnl;
                    if (pnlDictionary.ContainsKey(transfer.TokenInfo.Symbol))
                        pnl = pnlDictionary[transfer.TokenInfo.Symbol] - transfer.Amount;
                    else
                        pnl = -transfer.Amount;
                    // Always subtract fee in this case
                    pnl -= info.Fee;
                    pnlDictionary[transfer.TokenInfo.Symbol] = pnl;
                }
            }

            var result = ConvertToEth(pnlDictionary, tokenPrices);
            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(result);
        }

        // Converts PNL in tokens to ETH based on the provided token prices
        private IEnumerable<KeyValuePair<string, BigDecimal>> ConvertToEth(Dictionary<string, BigDecimal> pnlDictionary, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices)
        {
            if (tokenPrices == null || !tokenPrices.Any())
                return pnlDictionary.Select(kv => new KeyValuePair<string, BigDecimal>(kv.Key, kv.Value));

            var result = new List<KeyValuePair<string, BigDecimal>>();
            foreach (var pair in pnlDictionary)
            {
                var tokenPrice = tokenPrices.FirstOrDefault(tp => tp.Key == pair.Key);
                if (!tokenPrice.Equals(default(KeyValuePair<string, decimal>)))
                    result.Add(new KeyValuePair<string, BigDecimal>(pair.Key, pair.Value * (BigDecimal)tokenPrice.Value));
            }
            return result;
        }
    }
}
```