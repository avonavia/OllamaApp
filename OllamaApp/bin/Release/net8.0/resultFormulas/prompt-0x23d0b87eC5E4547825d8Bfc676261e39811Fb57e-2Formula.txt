[assembly: FormulaAssembly("SafeTransfer")]

namespace Sauron.Formula.SafeTransfer
{
    public class SafeTransferFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            var pnlResults = new Dictionary<string, BigDecimal>();

            // Initialize PNL for user addresses
            var userAddresses = info.Transfers?.Select(t => t.From).Distinct() ?? Enumerable.Empty<string>();
            foreach (var address in userAddresses)
                pnlResults[address] = BigDecimal.Zero;

            // Calculate PNL for each transfer
            foreach (var transfer in info.Transfers ?? Enumerable.Empty<TokenTransferInfo>())
            {
                var tokenPrice = tokenPrices?.FirstOrDefault(p => p.Key == transfer.TokenInfo.Symbol).Value ?? 0;
                var transferAmountInEth = transfer.Amount * new BigDecimal((decimal)tokenPrice);

                // If user sends tokens to themselves, no PNL change
                if (transfer.From == transfer.To) continue;

                // Subtract sent amount from sender's PNL
                pnlResults[transfer.From] -= transferAmountInEth + info.Fee;

                // Add received amount to receiver's PNL
                if (pnlResults.ContainsKey(transfer.To))
                    pnlResults[transfer.To] += transferAmountInEth;
                else
                    pnlResults[transfer.To] = transferAmountInEth;
            }

            // Return PNL results as KeyValuePairs
            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(pnlResults.Select(kvp => new KeyValuePair<string, BigDecimal>(kvp.Key, kvp.Value)));
        }
    }
}