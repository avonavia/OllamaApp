```csharp
[assembly: FormulaAssembly("_safeTransfer")]

namespace Sauron.Formula._safeTransfer;

using Nethereum.Hex.HexConvertors.Extensions;
using System.Numerics;

public class _safeTransferFormula : IFormulaPlugin
{
    public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
        IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
    {
        // Initialize the result list
        var results = new List<KeyValuePair<string, BigDecimal>>();

        // Get distinct tokens and their amounts from transfers
        var tokensWithAmounts = info.GetTokensWithAmounts(info.Transfers);

        foreach (var token in tokensWithAmounts)
        {
            if (token.Key == null || string.IsNullOrWhiteSpace(token.Key.Symbol)) continue;

            // Calculate PNL for each address
            var fromAddressPnl = CalculatePNL(info.FromAddress, token, info.Fee);
            results.Add(new KeyValuePair<string, BigDecimal>(info.FromAddress, fromAddressPnl));

            if (token.Key.Symbol.HexToByteArray().SequenceEqual(info.Input))
            {
                // The recipient address is encoded in the input data for safeTransfer function
                var toAddress = info.Input.Slice(40, 64).HexToAddress();
                if (!string.IsNullOrWhiteSpace(toAddress) && toAddress != info.FromAddress)
                {
                    var toAddressPnl = CalculatePNL(toAddress, token);
                    results.Add(new KeyValuePair<string, BigDecimal>(toAddress, toAddressPnl));
                }
            }
        }

        return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> { Result = results };
    }

    private BigDecimal CalculatePNL(string address, KeyValuePair<TokenInfo, BigDecimal> token, BigDecimal? fee = null)
    {
        if (address == info.FromAddress)
            return -token.Value - (fee ?? 0);
        else
            return token.Value;
    }
}
```