[assembly: FormulaAssembly("Sync")]

namespace Sauron.Formula.Sync
{
    using System;
    using System.Numerics;
    using System.Collections.Generic;
    using System.Linq;
    using Sauron.Core.Cryptography;
    using Sauron.Core.Models;

    public class SyncFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            // Find transfers for token0 and token1
            var token0Transfers = info.Transfers?.Where(t => t.TokenInfo.Symbol == "token0");
            var token1Transfers = info.Transfers?.Where(t => t.TokenInfo.Symbol == "token1");

            // Calculate balance of token0 and token1 for this contract address
            BigDecimal balanceToken0 = token0Transfers.Sum(t => t.Amount);
            BigDecimal balanceToken1 = token1Transfers.Sum(t => t.Amount);

            // We need to get the reserve0 and reserve1 from somewhere, as they are not provided in the transaction info.
            // For this example, we'll assume that these values can be fetched from another source or hard-coded.
            BigDecimal reserve0 = new BigDecimal("VALUE"); // Replace "VALUE" with actual value
            BigDecimal reserve1 = new BigDecimal("VALUE"); // Replace "VALUE" with actual value

            // Calculate the change in price for each token
            var deltaToken0 = (balanceToken0 * 2 + info.Fee) / (reserve0 + balanceToken0);
            var deltaToken1 = (balanceToken1 * 2 + info.Fee) / (reserve1 + balanceToken1);

            // The PNL is calculated as the difference between the current value of the tokens and their initial value
            BigDecimal initialValue = reserve0 * tokenPrices?.FirstOrDefault(t => t.Key == "token0").Value ?? 0 + reserve1 * tokenPrices?.FirstOrDefault(t => t.Key == "token1").Value ?? 0;
            BigDecimal currentValue = balanceToken0 * tokenPrices?.FirstOrDefault(t => t.Key == "token0").Value ?? 0 + balanceToken1 * tokenPrices?.FirstOrDefault(t => t.Key == "token1").Value ?? 0;

            BigDecimal pnl = currentValue - initialValue;

            // Return the PNL for each user address
            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> { Value = info.Addresses?.Select(address => new KeyValuePair<string, BigDecimal>(address, pnl)) };
        }
    }
}