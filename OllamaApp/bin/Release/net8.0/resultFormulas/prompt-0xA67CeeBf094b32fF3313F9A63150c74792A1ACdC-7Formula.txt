```csharp
// Sauron Formula Assembly Information
[assembly: System.Reflection.AssemblyCompany("Sauron")]
[assembly: System.Reflection.AssemblyProduct("Sauron Formulas")]
[assembly: System.Reflection.AssemblyCopyright("Copyright Â© Sauron 2022")]
[assembly: System.Reflection.AssemblyVersion("1.0.0.0")]

namespace Sauron.Formula.BurnUniswapV2
{
    using Nethereum.ABI.FunctionEncoding.Attributes;
    using System.Collections.Generic;
    using System.Numerics;

    public class BurnUniswapV2Formula : IFormulaPlugin
    {
        // Calculation Result for PNL. No Message is included as per the rules.
        public CalculationResult<BigDecimal?> Formula(TransactionInfo info, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            var balance0 = new BigDecimal((decimal)info.Outputs["balance0"]);
            var balance1 = new BigDecimal((decimal)info.Outputs["balance1"]);
            var totalSupply = new BigDecimal((decimal)info.ContractDecodedCallInputValues[nameof(totalSupply)]);

            var liquidity = new BigDecimal((decimal)info.ContractDecodedCallInputValues["liquidity"]);

            var amount0 = (liquidity * balance0) / totalSupply;
            var amount1 = (liquidity * balance1) / totalSupply;

            // User loses all their liquidity in the pool, so the PNL is negative of the value of tokens they receive.
            var pnlEth = -(amount0 * tokenPrices?.FirstOrDefault(x => x.Key == info.ContractDecodedCallInputValues["token0"].ToString()).Value ?? 0)
                         - (amount1 * tokenPrices?.FirstOrDefault(x => x.Key == info.ContractDecodedCallInputValues["token1"].ToString()).Value ?? 0);

            return new CalculationResult<BigDecimal?>(pnlEth, null);
        }
    }
}
```