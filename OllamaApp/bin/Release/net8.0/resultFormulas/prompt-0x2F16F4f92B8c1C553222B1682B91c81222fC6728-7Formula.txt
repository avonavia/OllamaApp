// Assuming `Transfers` is an IEnumerable<TokenTransferInfo> property of TransactionInfo class

[assembly: FormulaAssembly("betaNFT")]

namespace Sauron.Formula.betaNFT
{
    public class betaNFTFormula : IFormulaPlugin
    {
        // CalculationResult is a placeholder for the actual result type you're using in your application
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            // Check if the transaction was initiated by the owner
            if (info.FromAddress != info.OwnerAddress)
            {
                return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>("Transaction not initiated by the owner.", null);
            }

            // Check if there are any transfers
            if (info.Transfers == null || !info.Transfers.Any())
            {
                return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>("No transfers found in the transaction.", null);
            }

            // Get unique tokens transferred
            var tokens = info.Transfers.Select(t => t.TokenInfo).DistinctBy(t => t.Symbol);

            // Check if NFT flag is true and if only one token was transferred
            bool nftFlag = tokens.Count() == 1 && tokens.First().IsNFT;

            // Prepare the result as a single KeyValuePair with toTarget address and PNL (assuming no PNL calculation for this method)
            var result = new List<KeyValuePair<string, BigDecimal>>
            {
                new KeyValuePair<string, BigDecimal>(info.ToAddress, 0M) // Replace 0M with actual PNL calculation if needed
            };

            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>("Success", result);
        }
    }
}