```csharp
[assembly: FormulaAssembly("_safeTransfer")]

namespace Sauron.Formula._safeTransfer
{
    public class _safeTransferFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            // Check if the transaction has a single transfer and is not sending tokens to itself
            var transfers = GetTransfersForToken(info.Transfers, info.ToAddress);
            if (transfers?.Count() != 1 || transfers.First().From == info.ToAddress)
                return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(null);

            // Get the transfer details and token price
            var transfer = transfers.First();
            var tokenPrice = tokenPrices?.FirstOrDefault(p => p.Key == transfer.TokenInfo.Symbol).Value ?? 0;

            // Calculate the PNL for the user (sending tokens) in Eth
            var pnlInEth = -transfer.Amount * BigDecimal.FromDecimal((decimal)tokenPrice) / BigDecimal.FromDecimal(1e18);

            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(new[]
            {
                new KeyValuePair<string, BigDecimal>(info.ToAddress, pnlInEth)
            });
        }

        private IEnumerable<TransferInfo> GetTransfersForToken(IEnumerable<TransferInfo> transfers, string token)
        {
            return transfers?.Where(t => t.TokenInfo.Symbol == token);
        }
    }
}
```