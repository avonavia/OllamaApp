//Assembly name should be exact as function name in Solidity contract
   [assembly: FormulaAssembly("skim")]

   namespace Sauron.Formula.skim

   public class skimFormula : IFormulaPlugin
   {
       public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
           IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
       {
           // Initialize PNL dictionary
           var pnlDict = new Dictionary<string, BigDecimal>();

           // Check if Transfers exist and are valid for the formula
           if (info.Transfers == null || info.AdditionalData == null || !info.AdditionalData.TryGetValue("token0", out object? token0Obj) || !(token0Obj is string) ||
               !info.AdditionalData.TryGetValue("token1", out object? token1Obj) || !(token1Obj is string))
           {
               return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>
               {
                   Success = false,
                   Message = "Invalid TransactionInfo or missing token0/token1 data"
               };
           }

           // Convert tokens to string for comparison
           var _token0 = (string)token0Obj;
           var _token1 = (string)token1Obj;

           // Calculate PNL for each user address in the transaction
           foreach (var transfer in info.Transfers)
           {
               if ((transfer.ToAddress == info.FromAddress || transfer.ToAddress == info.ToAddress) &&
                   (transfer.TokenInfo.Symbol == _token0 || transfer.TokenInfo.Symbol == _token1))
               {
                   // Subtract the transferred amount from user's PNL
                   if (!pnlDict.ContainsKey(info.FromAddress))
                       pnlDict[info.FromAddress] = 0;

                   var tokenPrice = (from kvp in tokenPrices where kvp.Key == transfer.TokenInfo.Symbol select kvp.Value).FirstOrDefault();
                   if (tokenPrice != default)
                   {
                       pnlDict[info.FromAddress] -= transfer.Amount * (decimal)tokenPrice;
                   }
               }
           }

           // Subtract the fee from user's PNL
           var fee = info.FeeUsd ?? 0m;
           if (pnlDict.ContainsKey(info.FromAddress))
               pnlDict[info.FromAddress] -= fee;

           return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>
           {
               Success = true,
               Result = pnlDict.Select(kvp => new KeyValuePair<string, BigDecimal>(kvp.Key, (BigDecimal)kvp.Value))
           };
       }
   }