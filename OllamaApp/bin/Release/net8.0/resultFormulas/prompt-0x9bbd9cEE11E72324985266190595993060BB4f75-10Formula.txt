[assembly: FormulaAssembly("sync")]

namespace Sauron.Formula.sync
{
    public class syncFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            // Get token balances for the contract address in this transaction
            var balanceToken0 = info.Transfers?.FirstOrDefault(t => t.ToAddress == info.ContractAddress && t.TokenInfo.Symbol == "token0")?.Amount ?? 0;
            var balanceToken1 = info.Transfers?.FirstOrDefault(t => t.ToAddress == info.ContractAddress && t.TokenInfo.Symbol == "token1")?.Amount ?? 0;

            // Assuming reserve0 and reserve1 are properties of the contract, we cannot get them from TransactionInfo directly
            var reserve0 = BigDecimal.Zero; // Replace this with actual value or calculation
            var reserve1 = BigDecimal.Zero; // Replace this with actual value or calculation

            // Calculate PNL change for each user address involved in the transaction
            var pnlChanges = new List<KeyValuePair<string, BigDecimal>>();

            if (info.FromAddress != info.ToAddress)
            {
                // If tokens were transferred between different addresses, calculate PNL for both addresses
                var fromPnlChange = CalculatePNL(balanceToken0, balanceToken1, reserve0, reserve1, tokenPrices);
                var toPnlChange = -fromPnlChange; // Negative PNL change for the recipient address

                pnlChanges.Add(new KeyValuePair<string, BigDecimal>(info.FromAddress, fromPnlChange));
                pnlChanges.Add(new KeyValuePair<string, BigDecimal>(info.ToAddress, toPnlChange));
            }
            else
            {
                // If tokens were transferred within the same address (e.g., contract), calculate PNL for this address only
                var pnlChange = CalculatePNL(balanceToken0, balanceToken1, reserve0, reserve1, tokenPrices);
                pnlChanges.Add(new KeyValuePair<string, BigDecimal>(info.FromAddress, pnlChange));
            }

            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(pnlChanges);
        }

        private BigDecimal CalculatePNL(BigDecimal balanceToken0, BigDecimal balanceToken1, BigDecimal reserve0, BigDecimal reserve1, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices)
        {
            // Placeholder for PNL calculation based on the Solidity contract method. Replace with actual formula
            return 0; // Placeholder value, replace with actual calculation
        }
    }
}