Using the provided Solidity contract method `_safeTransfer`, here is a corresponding C# Formula method for PNL calculation based on the given rules:

```csharp
[assembly: FormulaAssembly("_safeTransfer")]

namespace Sauron.Formula._safeTransfer
{
    public class _safeTransferFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            var pnlResults = new List<KeyValuePair<string, BigDecimal>>();

            // Get unique tokens in transaction
            var tokens = info.GetDistinctTokens();
            if (tokens == null) return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>.Success(null);

            foreach (var tokenInfo in tokens)
            {
                // Get transfers for the current token
                var transfers = info.Transfers?.Where(t => t.TokenInfo.Symbol == tokenInfo.Symbol).ToList();
                if (transfers == null || !transfers.Any()) continue;

                // Calculate total sent and received amounts for each user address
                var balances = transfers
                    .GroupBy(t => t.FromAddress)
                    .Select(g => new { Address = g.Key, BalanceChange = g.Sum(t => -t.Amount) });

                balances = balances
                    .Concat(transfers
                        .GroupBy(t => t.ToAddress)
                        .Select(g => new { Address = g.Key, BalanceChange = g.Sum(t => t.Amount) }))
                    .GroupBy(b => b.Address)
                    .Select(g => new { Address = g.Key, BalanceChange = g.Sum(b => b.BalanceChange) })
                    .ToList();

                // Calculate PNL for each user address and convert to ETH
                var tokenPrice = tokenPrices?.FirstOrDefault(p => p.Key == tokenInfo.Symbol).Value ?? 0;
                foreach (var balance in balances)
                {
                    var pnl = BalanceChangeToPnl(balance.BalanceChange, tokenPrice);
                    if (pnl != BigDecimal.Zero)
                        pnlResults.Add(new KeyValuePair<string, BigDecimal>(balance.Address, pnl));
                }
            }

            return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>.Success(pnlResults);
        }

        private static BigDecimal BalanceChangeToPnl(BigDecimal balanceChange, decimal tokenPrice)
        {
            // If user received tokens, PNL is positive; if sent tokens, PNL is negative
            return balanceChange > BigDecimal.Zero ? -balanceChange * (decimal)tokenPrice : balanceChange * (decimal)tokenPrice;
        }
    }
}
```