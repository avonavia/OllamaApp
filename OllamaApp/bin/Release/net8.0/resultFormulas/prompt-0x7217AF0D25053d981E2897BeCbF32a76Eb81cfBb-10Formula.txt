[assembly: FormulaAssembly("SyncFormula")]

namespace Sauron.Formula.SyncFormula
{
    public class SyncFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            // Initialize PNL dictionary
            var pnlDictionary = new Dictionary<string, BigDecimal>();

            // Get unique tokens in transaction
            var tokens = info.GetDistinctTokens();

            if (tokens != null && tokenPrices != null)
            {
                foreach (var token in tokens)
                {
                    // Filter out transfers for the current token
                    var tokenTransfers = info.Transfers?.Where(t => t.TokenInfo.Symbol == token.Symbol);

                    if (tokenTransfers != null)
                    {
                        // Calculate total amount of tokens sent or received by this contract in transaction
                        var totalAmount = BigDecimal.Zero;

                        foreach (var transfer in tokenTransfers)
                        {
                            if (transfer.ToAddress == info.ContractAddress)
                            {
                                // If the contract receives tokens, increase its total amount
                                totalAmount += transfer.Amount;
                            }
                            else
                            {
                                // If the contract sends tokens, decrease its total amount
                                totalAmount -= transfer.Amount;
                            }
                        }

                        // Calculate PNL in ETH for this token based on its price
                        var tokenPrice = new BigDecimal(tokenPrices.FirstOrDefault(p => p.Key == token.Symbol).Value);
                        var pnlInEth = totalAmount * tokenPrice;

                        // Add PNL to dictionary (contract address as key)
                        if (!pnlDictionary.ContainsKey(info.ContractAddress))
                            pnlDictionary[info.ContractAddress] = BigDecimal.Zero;

                        pnlDictionary[info.ContractAddress] += pnlInEth;
                    }
                }
            }

            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(pnlDictionary);
        }
    }
}