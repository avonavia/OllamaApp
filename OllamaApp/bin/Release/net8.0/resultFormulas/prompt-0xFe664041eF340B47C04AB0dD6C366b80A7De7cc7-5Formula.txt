```csharp
[assembly: FormulaAssembly("_mintFee")]

namespace Sauron.Formula._mintFee
{
    public class _mintFeeFormula : IFormulaPlugin
    {
        // C# formula for _mintFee function in Solidity contract
        // Calculates PNL for feeTo address if there is a minting fee, otherwise returns NULL
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            // Get reserve0 and reserve1 from TransactionInfo object
            var reserve0 = (BigDecimal)info.DecodedData["_reserve0"];
            var reserve1 = (BigDecimal)info.DecodedData["_reserve1"];

            // Calculate rootK and rootKLast
            BigDecimal rootK = Math.Sqrt(reserve0 * reserve1);
            BigDecimal rootKLast = Math.Sqrt((BigDecimal)info.ContractState["kLast"]);

            if (rootK > rootKLast && info.FactoryFeeTo != "0x0") // Check if feeTo is not zero address
            {
                var totalSupply = (BigDecimal)info.ContractState["totalSupply"];
                BigDecimal numerator = totalSupply * (rootK - rootKLast);
                BigDecimal denominator = rootK * 5 + rootKLast;
                BigDecimal liquidity = numerator / denominator;

                if (liquidity > 0) // Check if there is any minted liquidity
                {
                    var feeToPNL = -info.Fee; // Fee is already subtracted from user's balance, so we return negative PNL for feeTo

                    return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(new[] { new KeyValuePair<string, BigDecimal>(info.FactoryFeeTo, feeToPNL) });
                }
            }

            return null; // Return NULL if there is no minting fee or liquidity is zero
        }
    }
}
```