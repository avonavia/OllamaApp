```csharp
using Sauron.Formula.AdminTransfer;
using System.Collections.Generic;
using Nethereum.Util;

[assembly: FormulaAssembly("AdminTransfer")]

namespace Sauron.Formula.AdminTransfer
{
    public class AdminTransferFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            var pnl = new Dictionary<string, BigDecimal>();

            // We only consider the case where the transaction was successful.
            if (!info.Success) return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>.Empty;

            for (int i = 0; i < info.FunctionParameters.Length; i++)
            {
                var param = info.FunctionParameters[i] as TokenParams;
                if (param != null)
                {
                    // Check if the token is ERC721 or ERC1155 and calculate PNL accordingly.
                    // For simplicity, we assume that tokenData can be accessed directly from info object.
                    var data = info.TokenData[param.token];
                    var toAddress = (string)info.FunctionParameters[i + 1];
                    var walletAddress = (string)info.FunctionParameters[i + 2];

                    if (data.tokenType == TokenType.ERC721)
                    {
                        for (int j = 0; j < param.tokenId.Length; j++)
                            CalculatePnlForAddress(pnl, toAddress, walletAddress, tokenPrices);
                    }
                    else // ERC1155
                    {
                        CalculatePnlForAddress(pnl, toAddress, walletAddress, param.amount, tokenPrices);
                    }
                }
            }

            return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>.Success(pnl);
        }

        private void CalculatePnlForAddress(Dictionary<string, BigDecimal> pnl, string toAddress, string walletAddress, Unit amount = null, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            if (!pnl.ContainsKey(toAddress))
                pnl[toAddress] = new BigDecimal(0);

            // Subtract the token value from the to address and add it to the wallet address.
            if (amount != null && tokenPrices != null)
            {
                var tokenPrice = tokenPrices.FirstOrDefault(p => p.Key == info.FunctionParameters[0].token).Value;
                var tokenAmountInEth = new BigDecimal((decimal)amount.Value * (decimal)tokenPrice);

                pnl[toAddress] -= tokenAmountInEth;

                if (!pnl.ContainsKey(walletAddress))
                    pnl[walletAddress] = new BigDecimal(0);

                pnl[walletAddress] += tokenAmountInEth;
            }
        }
    }
}
```