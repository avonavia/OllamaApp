[assembly: FormulaAssembly("sync")]

namespace Sauron.Formula.sync
{
    public class syncFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            var token0Balance = info.Transfers.Where(t => t.TokenInfo.Symbol == "TOKEN0").Sum(t => t.Amount);
            var token1Balance = info.Transfers.Where(t => t.TokenInfo.Symbol == "TOKEN1").Sum(t => t.Amount);
            // assuming reserve0 and reserve1 are known or can be retrieved from the contract
            var reserve0 = BigDecimal.Zero;
            var reserve1 = BigDecimal.Zero;

            var pnl = UpdatePNL(token0Balance, token1Balance, reserve0, reserve1) - info.Fee;

            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(new List<KeyValuePair<string, BigDecimal>>() {
                new KeyValuePair<string, BigDecimal>(info.FromAddress, pnl)
            });
        }

        private BigDecimal UpdatePNL(BigDecimal token0Balance, BigDecimal token1Balance, BigDecimal reserve0, BigDecimal reserve1)
        {
            // assume _update function in Solidity contract does some calculation to find PNL
            // replace this with the actual C# code for that calculation
            return (token0Balance * reserve1 + token1Balance * reserve0) / (reserve0 * reserve1);
        }
    }
}