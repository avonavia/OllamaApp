[assembly: FormulaAssembly("sync")]

namespace Sauron.Formula.sync
{
    public class syncFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            if (info.Transfers == null || !tokenPrices?.Any() ?? true)
                return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>.Failure(null);

            // Get distinct tokens in transaction
            var tokens = info.GetDistinctTokens();

            if (tokens == null || !tokens.Any())
                return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>.Failure(null);

            var results = new Dictionary<string, BigDecimal>();

            foreach (var token in tokens)
            {
                // Get all transfers related to the token
                var transfersRelatedToToken = info.Transfers.Where(t => t.TokenInfo.Symbol == token.Symbol);

                if (!transfersRelatedToToken.Any())
                    continue;

                // Calculate total amount of token transferred
                var totalAmount = transfersRelatedToToken.Sum(t => t.Amount);

                // Get price of the token
                var tokenPrice = tokenPrices?.FirstOrDefault(tp => tp.Key == token.Symbol).Value ?? 0;

                if (tokenPrice <= 0)
                    continue;

                // Calculate PNL in ETH for the token
                var pnlInEth = totalAmount * new BigDecimal((decimal)tokenPrice);

                // Subtract fee from PNL if necessary
                if (info.From != info.To)
                    pnlInEth -= info.Fee;

                results[info.From] = results.ContainsKey(info.From) ? results[info.From] + pnlInEth : pnlInEth;
            }

            return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>.Success(results);
        }
    }
}