```csharp
[assembly: FormulaAssembly("_mintFee")]

namespace Sauron.Formula._MintFee
{
    public class _MintFeeFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            var pnl = new Dictionary<string, BigDecimal>();

            // Check if feeTo is not address(0)
            bool feeOn = info.FeeTo != "0x0";

            if (feeOn)
            {
                // Check if kLast is not equal to 0
                if (info.KLast != BigDecimal.Zero)
                {
                    BigDecimal rootK = BigDecimal.Sqrt(info.Reserve0 * info.Reserve1);
                    BigDecimal rootKLast = BigDecimal.Sqrt(info.KLast);

                    // Check if rootK > rootKLast
                    if (rootK > rootKLast)
                    {
                        BigDecimal numerator = info.TotalSupply * (rootK - rootKLast);
                        BigDecimal denominator = rootK * 5 + rootKLast;
                        BigDecimal liquidity = numerator / denominator;

                        // If liquidity is greater than 0, add it to feeTo's PNL
                        if (liquidity > 0)
                            AddOrUpdatePnl(pnl, info.FeeTo, liquidity);
                    }
                }
            }
            else if (info.KLast != BigDecimal.Zero)
            {
                // If feeOn is false and kLast is not equal to 0, set kLast to 0
                info.KLast = BigDecimal.Zero;
            }

            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(pnl);
        }

        private void AddOrUpdatePnl(Dictionary<string, BigDecimal> pnl, string address, BigDecimal amount)
        {
            if (pnl.ContainsKey(address))
                pnl[address] += amount;
            else
                pnl[address] = amount;
        }
    }
}
```