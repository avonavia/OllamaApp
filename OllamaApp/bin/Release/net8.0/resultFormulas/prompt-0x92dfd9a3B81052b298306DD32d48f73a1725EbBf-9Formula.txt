//Method to calculate PNL for a given address based on token transfers
    public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>> Formula(TransactionInfo info, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
    {
        var pnl = new Dictionary<string, BigDecimal>();

        if (info.Transfers != null && tokenPrices != null)
        {
            foreach (var transfer in info.Transfers)
            {
                var tokenPrice = tokenPrices.FirstOrDefault(tp => tp.Key == transfer.TokenInfo.Symbol).Value;

                // Check if the address is a sender or receiver and calculate PNL accordingly
                if (transfer.FromAddress.ToLower() == info.SenderAddress.ToLower())
                {
                    var loss = BigDecimal.Multiply(tokenPrice, Convert.ToDouble(transfer.Amount));
                    if (!pnl.ContainsKey(info.SenderAddress))
                        pnl[info.SenderAddress] = BigDecimal.Zero;
                    pnl[info.SenderAddress] -= loss;
                }

                if (transfer.ToAddress.ToLower() == info.SenderAddress.ToLower())
                {
                    var gain = BigDecimal.Multiply(tokenPrice, Convert.ToDouble(transfer.Amount));
                    if (!pnl.ContainsKey(info.SenderAddress))
                        pnl[info.SenderAddress] = BigDecimal.Zero;
                    pnl[info.SenderAddress] += gain;
                }
            }

            // Subtract fee from PNL (assuming fee is in ETH)
            if (pnl.ContainsKey(info.SenderAddress))
                pnl[info.SenderAddress] -= info.FeeInEth;
        }

        return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>>(true, null, pnl.Select(kvp => new KeyValuePair<string, BigDecimal>(kvp.Key, kvp.Value)));
    }