//Assembly attribute for formula name
[assembly: FormulaAssembly("SyncPNL")]

namespace Sauron.Formula.SyncPNL
{
    public class SyncPNLFormula : IFormulaPlugin
    {
        /// <summary>
        /// Calculates the PNL for sync function in the contract based on token balances and reserves
        /// </summary>
        /// <param name="info">TransactionInfo object containing all necessary transaction data</param>
        /// <param name="tokenPrices">Optional list of token prices to calculate PNL in ETH</param>
        /// <returns>CalculationResult with a dictionary of user addresses and their corresponding PNLs or null if calculation fails</returns>
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            //Check if there are any transfers in the transaction
            if (info.Transfers == null || !info.Transfers.Any())
                return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(null);

            //Initialize dictionaries to store token balances and reserves
            var tokenBalances = new Dictionary<TokenInfo, BigDecimal>();
            var reserves = new Dictionary<TokenInfo, BigDecimal>();

            //Populate tokenBalances dictionary with token balances from transfers
            foreach (var transfer in info.Transfers)
            {
                if (!tokenBalances.ContainsKey(transfer.TokenInfo))
                    tokenBalances[transfer.TokenInfo] = BigDecimal.Zero;

                //Subtract fee only if the recipient is not the same as the sender to avoid double counting
                if (info.ToAddress != info.FromAddress)
                    tokenBalances[transfer.TokenInfo] += transfer.Amount - transfer.Fee;
                else
                    tokenBalances[transfer.TokenInfo] += transfer.Amount;
            }

            //Populate reserves dictionary with reserve values from contract data (not shown in this example)

            //Calculate PNL for each user address
            var pnl = new Dictionary<string, BigDecimal>();
            foreach (var pair in tokenBalances)
            {
                if (!reserves.ContainsKey(pair.Key)) continue;

                var tokenPrice = BigDecimal.One;
                if (tokenPrices != null && tokenPrices.Any(t => t.Key == pair.Key.Symbol))
                    tokenPrice = new BigDecimal((decimal)tokenPrices.First(t => t.Key == pair.Key.Symbol).Value);

                var balanceInEth = pair.Value * tokenPrice;
                var reserveInEth = reserves[pair.Key] * tokenPrice;
                var pnlForAddress = (balanceInEth - reserveInEth) / BigDecimal.Two;

                if (!pnl.ContainsKey(info.FromAddress))
                    pnl[info.FromAddress] = BigDecimal.Zero;

                pnl[info.FromAddress] += pnlForAddress;
            }

            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(pnl);
        }
    }
}