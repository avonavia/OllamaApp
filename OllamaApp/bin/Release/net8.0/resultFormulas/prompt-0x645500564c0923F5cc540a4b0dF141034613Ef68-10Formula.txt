[assembly: FormulaAssembly("Sync")]

namespace Sauron.Formula.Sync
{
    using Nethereum.Hex.HexConvertors.Extensions;
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Numerics;
    using Sauron.Framework;

    public class SyncFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            // Ensure that Transfers are not null or empty
            if (info.Transfers == null || !info.Transfers.Any())
                return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(null);

            // Filter out the token transfers relevant to this contract
            var tokenTransfers = info.Transfers
                .Where(t => t.ToAddress == info.ContractAddress || t.FromAddress == info.ContractAddress)
                .ToList();

            if (!tokenTransfers.Any())
                return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(null);

            // Get distinct tokens and their initial balances in the contract
            var tokens = tokenTransfers
                .Select(t => t.TokenInfo)
                .DistinctBy(t => t.Symbol)
                .ToDictionary(t => t, _ => new BigDecimal(0));

            // Calculate the final balances of each token in the contract
            foreach (var transfer in tokenTransfers)
            {
                if (transfer.FromAddress == info.ContractAddress)
                    tokens[transfer.TokenInfo] -= transfer.Amount;

                if (transfer.ToAddress == info.ContractAddress)
                    tokens[transfer.TokenInfo] += transfer.Amount;
            }

            // Calculate PNL for each user address based on the changes in token balances and their prices
            var pnl = new Dictionary<string, BigDecimal>();
            foreach (var pair in tokens)
            {
                if (!tokenPrices?.Any(p => p.Key == pair.Key.Symbol) ?? false)
                    continue; // Skip tokens with unknown price

                var tokenPrice = tokenPrices.First(p => p.Key == pair.Key.Symbol).Value;
                if (pair.Key.Decimals != null && pair.Key.Decimals > 0)
                    tokenPrice /= Math.Pow(10, pair.Key.Decimals.Value); // Adjust price for token decimals

                var changeInBalance = pair.Value; // This is the final balance minus initial balance (which was 0)
                var pnlChange = BigDecimal.Multiply(changeInBalance, new BigDecimal((decimal)tokenPrice));

                if (!pnl.ContainsKey(pair.Key.Symbol))
                    pnl[pair.Key.Symbol] = new BigDecimal(0);

                pnl[pair.Key.Symbol] += pnlChange; // Accumulate PNL for each user address
            }

            // Subtract fees from the PNL
            if (info.Fee != null && info.Fee.Value > 0)
            {
                var ethPrice = tokenPrices?.FirstOrDefault(p => p.Key == "ETH").Value ?? 1; // Assume ETH price is known, default to 1 if not provided
                var feeInEth = new BigDecimal((decimal)info.Fee.Value / (10m * (decimal)Math.Pow(10, 18))); // Convert Wei to Eth
                var feeCost = BigDecimal.Multiply(feeInEth, new BigDecimal(ethPrice));

                if (!pnl.ContainsKey("ETH"))
                    pnl["ETH"] = new BigDecimal(0);

                pnl["ETH"] -= feeCost; // Subtract fee from PNL in ETH
            }

            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(pnl.Select(p => new KeyValuePair<string, BigDecimal>(p.Key, p.Value)));
        }
    }
}