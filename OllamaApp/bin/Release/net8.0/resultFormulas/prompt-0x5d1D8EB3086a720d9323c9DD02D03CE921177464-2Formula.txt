```csharp
[assembly: FormulaAssembly("SafeTransfer")]

namespace Sauron.Formula.SafeTransfer
{
    public class SafeTransferFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            // Validate input
            if (info == null || info.Transfers == null || !tokenPrices?.Any() ?? true)
                return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>>.Fail("Invalid Input");

            var userAddresses = new HashSet<string>(info.FromAddress);
            if (info.ToAddress != null && info.ToAddress != info.FromAddress)
                userAddresses.Add(info.ToAddress);

            // Calculate PNL
            var pnlByAddress = userAddresses.ToDictionary(addr => addr, _ => new BigDecimal());
            foreach (var transfer in info.Transfers)
            {
                if (!tokenPrices.Any(tp => tp.Key == transfer.TokenInfo.Symbol))
                    continue; // We don't have the price for this token

                var tokenPrice = new BigDecimal((decimal)tokenPrices.First(tp => tp.Key == transfer.TokenInfo.Symbol).Value);
                var amountInEth = BigDecimal.Multiply(transfer.Amount, tokenPrice);

                if (transfer.FromAddress == info.ToAddress) // User is receiving tokens
                    pnlByAddress[info.ToAddress] += amountInEth;
                else if (transfer.ToAddress == info.ToAddress) // User is sending tokens
                    pnlByAddress[info.ToAddress] -= amountInEth;
            }

            // Subtract Fee from PNL
            if (!string.IsNullOrEmpty(info.Fee))
                pnlByAddress[info.FromAddress] -= new BigDecimal((decimal)info.Fee);

            return CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>>.Success(pnlByAddress.Select(kv => new KeyValuePair<string, BigDecimal>(kv.Key, kv.Value)));
        }
    }
}
```