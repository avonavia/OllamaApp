// Assembly info for Formula
[assembly: FormulaAssembly("Mint")]

namespace Sauron.Formula.MINT
{
    public class MINTFormula : IFormulaPlugin
    {
        public CalculationResult<BigDecimal?> Formula(TransactionInfo info, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            BigDecimal balance0 = (BigDecimal)info.FromTokenBalance;
            BigDecimal balance1 = (BigDecimal)info.ToTokenBalance;
            BigDecimal reserve0 = (BigDecimal)info.Reserve0;
            BigDecimal reserve1 = (BigDecimal)info.Reserve1;
            BigDecimal totalSupply = (BigDecimal)info.TotalSupply;

            // Calculate amount of tokens to be minted
            BigDecimal amount0 = balance0 - reserve0;
            BigDecimal amount1 = balance1 - reserve1;

            // Check if fee is on and calculate liquidity
            bool feeOn = (reserve0 > 0) && (reserve1 > 0);
            BigDecimal liquidity;
            if (totalSupply == 0)
                liquidity = BigDecimal.Sqrt(amount0 * amount1) - BigDecimal.Parse("1e3"); // MINIMUM_LIQUIDITY is assumed to be 10^3
            else
                liquidity = BigDecimal.Min((amount0 * totalSupply / reserve0), (amount1 * totalSupply / reserve1));

            if (liquidity <= 0) return CalculationResult<BigDecimal?>.Failure("INSUFFICIENT_LIQUIDITY_MINTED");

            // Calculate PNL for the user. In this case, as the user is receiving liquidity tokens, there's no immediate financial loss or gain
            BigDecimal pnl = 0;

            if (info.ToAddress != info.FromAddress)
                pnl -= info.Fee; // Subtract Fee only if the recipient address is different from the sender address

            return CalculationResult<BigDecimal?>.Success(pnl);
        }
    }
}