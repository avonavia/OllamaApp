//Method for PNL calculation of skim function in Solidity contract

[assembly: FormulaAssembly("skim")]

namespace Sauron.Formula.skim
{
    public class skimFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            if (info == null || info.Transfers == null || !tokenPrices?.Any() ?? true)
                return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(null);

            var pnl = new Dictionary<string, BigDecimal>();
            var token0Symbol = info.GetDistinctTokens().FirstOrDefault(t => t.Address == info.ContractInfo?.Token0)?.Symbol;
            var token1Symbol = info.GetDistinctTokens().FirstOrDefault(t => t.Address == info.ContractInfo?.Token1)?.Symbol;

            if (!string.IsNullOrEmpty(token0Symbol))
            {
                pnl[info.FromAddress] = pnl.ContainsKey(info.FromAddress) ? pnl[info.FromAddress] : BigDecimal.Zero;
                pnl[info.FromAddress] -= info.Transfers
                    .Where(t => t.TokenInfo?.Symbol == token0Symbol && t.FromAddress == info.ContractInfo?.Address)
                    .Sum(t => t.Amount);
            }

            if (!string.IsNullOrEmpty(token1Symbol))
            {
                pnl[info.FromAddress] = pnl.ContainsKey(info.FromAddress) ? pnl[info.FromAddress] : BigDecimal.Zero;
                pnl[info.FromAddress] -= info.Transfers
                    .Where(t => t.TokenInfo?.Symbol == token1Symbol && t.FromAddress == info.ContractInfo?.Address)
                    .Sum(t => t.Amount);
            }

            // Subtract fee from PNL
            pnl[info.FromAddress] -= new BigDecimal(info.Fee ?? 0, 18);

            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(pnl.Select(x => new KeyValuePair<string, BigDecimal>(x.Key, x.Value)));
        }
    }
}