//Assembly info for PNL calculation
[assembly: FormulaAssembly("sync")]

namespace Sauron.Formula.Sync
{
    public class SyncFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            //Calculate balance of tokens in the contract
            var token0Balance = info.Transfers?.Where(t => t.TokenInfo.Symbol == "token0").Sum(t => t.Amount) ?? 0;
            var token1Balance = info.Transfers?.Where(t => t.TokenInfo.Symbol == "token1").Sum(t => t.Amount) ?? 0;

            //Assuming reserve0 and reserve1 are stored in some property of TransactionInfo, adjust according to your actual data structure
            var reserve0 = info.Reserve0;
            var reserve1 = info.Reserve1;

            //Calculate PNL for token0
            var pnlToken0 = (token0Balance * new BigDecimal(reserve1)) / (token0Balance + new BigDecimal(reserve0));

            //Calculate PNL for token1
            var pnlToken1 = (token1Balance * new BigDecimal(reserve0)) / (token1Balance + new BigDecimal(reserve1));

            //Subtract fee from the PNL if applicable (assuming Fee is a property of TransactionInfo)
            pnlToken0 -= info.Fee;
            pnlToken1 -= info.Fee;

            //Convert PNL to Eth if token prices are provided
            BigDecimal priceOfEth = 1;
            var token0Price = tokenPrices?.FirstOrDefault(t => t.Key == "token0").Value ?? 0;
            var token1Price = tokenPrices?.FirstOrDefault(t => t.Key == "token1").Value ?? 0;

            if (token0Price > 0)
                pnlToken0 *= new BigDecimal((decimal)priceOfEth / token0Price);
            if (token1Price > 0)
                pnlToken1 *= new BigDecimal((decimal)priceOfEth / token1Price);

            //Return PNL for each user address. Assuming fromAddress and toAddress are properties of TransactionInfo, adjust according to your actual data structure
            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>
            {
                Result = new List<KeyValuePair<string, BigDecimal>>()
                {
                    new KeyValuePair<string, BigDecimal>(info.FromAddress, pnlToken0 + pnlToken1), //Add PNL for both tokens
                    new KeyValuePair<string, BigDecimal>(info.ToAddress, -pnlToken0 - pnlToken1) //Subtract PNL from other address if it's different
                }
            };
        }
    }
}