//Assembly information for PNL calculation
[assembly: FormulaAssembly("SafeTransfer")]

namespace Sauron.Formula.SafeTransfer
{
    public class SafeTransferFormula : IFormulaPlugin
    {
        /// <summary>
        /// Calculates the Profit and Loss for a safe transfer of tokens
        /// </summary>
        /// <param name="info">Transaction information</param>
        /// <param name="tokenPrices">Token prices used in calculation</param>
        /// <returns>CalculationResult with Address-PNL pairs or NULL</returns>
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            //Check if there are any transfers in the transaction
            if (info.Transfers == null || !info.Transfers.Any()) return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> { Success = true };

            var pnl = new Dictionary<string, BigDecimal>();

            //Iterate over each transfer in the transaction
            foreach (var transfer in info.Transfers)
            {
                var tokenSymbol = transfer.TokenInfo.Symbol;
                var fromAddress = info.From;
                var toAddress = transfer.To;
                var amount = transfer.Amount;

                //Subtract the fee only if the recipient is not the same as the sender
                if (fromAddress != toAddress)
                    amount -= info.Fee;

                //Calculate the PNL in Eth by multiplying the token amount with its price
                var pnlInEth = amount * tokenPrices?.FirstOrDefault(p => p.Key == tokenSymbol).Value ?? 0;

                //Add or update the PNL for each address
                if (pnl.ContainsKey(fromAddress))
                    pnl[fromAddress] -= pnlInEth;
                else
                    pnl[fromAddress] = -pnlInEth;

                if (pnl.ContainsKey(toAddress))
                    pnl[toAddress] += pnlInEth;
                else
                    pnl[toAddress] = pnlInEth;
            }

            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>
            {
                Success = true,
                Result = pnl.Select(kvp => new KeyValuePair<string, BigDecimal>(kvp.Key, (BigDecimal)kvp.Value))
            };
        }
    }
}