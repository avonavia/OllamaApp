```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using Sauron.Core.Cryptos.Ethereum.Contracts.Common;
using Sauron.Formula.Common.Models;

namespace Sauron.Formula.UniswapV2Burn
{
    public class UniswapV2BurnFormula : IFormulaPlugin
    {
        public CalculationResult<BigDecimal?> Formula(TransactionInfo info, IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            // Get the necessary information from TransactionInfo object
            var reserve0 = new BigDecimal(info.Reserve0);
            var reserve1 = new BigDecimal(info.Reserve1);
            var totalSupply = new BigDecimal(info.TotalSupply);
            var balance0 = new BigDecimal(info.Balance0);
            var balance1 = new BigDecimal(info.Balance1);
            var liquidity = new BigDecimal(info.Liquidity);
            var toAddress = info.To;
            var fromAddress = info.From;

            // Calculate the amounts of tokens burned
            var amount0 = liquidity * balance0 / totalSupply;
            var amount1 = liquidity * balance1 / totalSupply;

            // If toAddress is not the same as fromAddress, user sent money to another address, so PNL is negative
            if (toAddress != fromAddress)
                return new CalculationResult<BigDecimal?>(-amount0 * tokenPrices?.FirstOrDefault(x => x.Key == info.Token0).Value - amount1 * tokenPrices?.FirstOrDefault(x => x.Key == info.Token1).Value);
            else
                return new CalculationResult<BigDecimal?>(BigDecimal.Zero); // If user sent tokens to themselves, PNL is zero
        }
    }
}
```