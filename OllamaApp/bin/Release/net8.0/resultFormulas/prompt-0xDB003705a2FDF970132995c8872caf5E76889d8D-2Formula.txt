//Assembly information for PNL calculation formula
[assembly: FormulaAssembly("_safeTransfer")]

namespace Sauron.Formula._safeTransfer
{
    public class _safeTransferFormula : IFormulaPlugin
    {
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            //Get distinct tokens in transaction
            var tokens = GetDistinctTokens(info.Transfers);

            if (tokens == null) return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>("No transfers found");

            //Initialize PNL dictionary for each user address
            var pnlDictionary = info.FromAddresses.Union(info.ToAddresses).Distinct().ToDictionary(a => a, _ => new BigDecimal(0));

            foreach (var token in tokens)
            {
                //Get transfers for current token
                var tokenTransfers = info.Transfers.Where(t => t.TokenInfo.Symbol == token.Symbol);

                //Calculate total transfer amount for each address in transaction
                var addressAmounts = tokenTransfers.GroupBy(t => t.FromAddress)
                    .Select(g => new KeyValuePair<string, BigDecimal>(g.Key, g.Sum(t => -t.Amount))).ToList();

                //Add recipient addresses and their transfer amounts to the dictionary
                foreach (var item in tokenTransfers.GroupBy(t => t.ToAddress)
                    .Select(g => new KeyValuePair<string, BigDecimal>(g.Key, g.Sum(t => t.Amount))))
                {
                    if (!addressAmounts.Any(a => a.Key == item.Key))
                        addressAmounts.Add(item);
                    else
                        addressAmounts.First(a => a.Key == item.Key).Value += item.Value;
                }

                //Update PNL for each user in the transaction
                foreach (var pair in addressAmounts)
                {
                    var tokenPrice = tokenPrices?.FirstOrDefault(tp => tp.Key == token.Symbol).Value ?? 1M;
                    pnlDictionary[pair.Key] += pair.Value * new BigDecimal((decimal)tokenPrice);
                }
            }

            //Subtract transaction fee from sender's PNL
            if (pnlDictionary.ContainsKey(info.FromAddresses.First()))
                pnlDictionary[info.FromAddresses.First()] -= info.Fee;

            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(pnlDictionary);
        }

        //Method to get DISTINCT tokens in transaction
        private IEnumerable<TokenInfo>? GetDistinctTokens(List<TokenTransferInfo> transfers)
        {
            return transfers?.Select(t => t.TokenInfo).DistinctBy(t => t.Symbol);
        }
    }
}