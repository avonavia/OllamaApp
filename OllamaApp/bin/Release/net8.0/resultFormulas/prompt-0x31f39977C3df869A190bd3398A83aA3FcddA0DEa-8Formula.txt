Sure, here is a simplified version of how you could calculate the PNL for a given user in a swap transaction in C#. This is a basic implementation and does not include some of the more complex safety checks or error handling that are present in the Solidity contract.

```csharp
using System;
using Nethereum.Web3;
using Nethereum.Contracts;
using Nethereum.RPC.Eth.DTOs;
using SystemNumerics;

namespace UniswapV2PNLCalculator
{
    public class PNLCalculator
    {
        private readonly Web3 _web3;
        private readonly Contract _contract;
        private readonly string _userAddress;

        public PNLCalculator(Web3 web3, Contract contract, string userAddress)
        {
            _web3 = web3;
            _contract = contract;
            _userAddress = userAddress;
        }

        // Calculate PNL for a swap transaction
        public async Task<BigInteger> CalculatePNLAsync(BigInteger amount0Out, BigInteger amount1Out, string to)
        {
            var balanceBeforeSwapTask = GetBalanceOfUserTokensAsync();

            // Perform the swap transaction
            var swapFunction = _contract.GetFunction("swap");
            await swapFunction.SendTransactionAsync(_userAddress, new object[] { amount0Out, amount1Out, to });

            var balanceAfterSwapTask = GetBalanceOfUserTokensAsync();

            // Wait for both tasks to complete
            await Task.WhenAll(balanceBeforeSwapTask, balanceAfterSwapTask);

            var (balance0BeforeSwap, balance1BeforeSwap) = balanceBeforeSwapTask.Result;
            var (balance0AfterSwap, balance1AfterSwap) = balanceAfterSwapTask.Result;

            // Calculate the PNL
            var pnl = (balance0AfterSwap - balance0BeforeSwap + balance1AfterSwap - balance1BeforeSwap);

            return pnl;
        }

        // Get the balances of the user's tokens in the pool
        private async Task<(BigInteger, BigInteger)> GetBalanceOfUserTokensAsync()
        {
            var token0Function = _contract.GetFunction("token0");
            var token1Function = _contract.GetFunction("token1");
            var token0Address = await token0Function.CallAsync<string>();
            var token1Address = await token1Function.CallAsync<string>();

            var balanceOfToken0Function = new Contract(_web3, GetERC20Abi(), token0Address).GetFunction("balanceOf");
            var balanceOfToken1Function = new Contract(_web3, GetERC20Abi(), token1Address).GetFunction("balanceOf");

            var balance0Task = balanceOfToken0Function.CallAsync<BigInteger>(_userAddress);
            var balance1Task = balanceOfToken1Function.CallAsync<BigInteger>(_userAddress);

            // Wait for both tasks to complete and return the results
            await Task.WhenAll(balance0Task, balance1Task);
            return (balance0Task.Result, balance1Task.Result);
        }

        // Get ERC20 ABI
        private string GetERC20Abi()
        {
            return @"[{""constant"":true,""inputs"":[{""name"":""who"",""type"":""address""}],""name"":""balanceOf"",""outputs"":[{""name"":"""",""type"":""uint256""}],""payable"":false,""stateMutability"":""view"",""type"":""function""}]";
        }
    }
}
```