// Assembly info for PNL calculation
   [assembly: FormulaAssembly("_DeployVistaPonziNetwork")]

   namespace Sauron.Formula._DeployVistaPonziNetwork
   {
       public class _DeployVistaPonziNetworkFormula : IFormulaPlugin
       {
           // Formula method for PNL calculation
           public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
               IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
           {
               // Initializing a dictionary to hold user addresses and their corresponding PNL
               var pnlResult = new Dictionary<string, BigDecimal>();

               // Checking if transfers exist in the transaction info
               if (info.Transfers != null && tokenPrices != null)
               {
                   foreach (var transfer in info.Transfers)
                   {
                       // For each transfer, add or subtract the value of tokens from user's PNL
                       // Subtract the amount if user is deploying the network (sender is the user)
                       if (transfer.FromAddress == info.Sender && tokenPrices.Any(t => t.Key == transfer.TokenInfo.Symbol))
                           pnlResult[info.Sender] = pnlResult.ContainsKey(info.Sender) ? pnlResult[info.Sender] - (transfer.Amount * BigDecimal.FromDecimal((decimal)tokenPrices.First(t => t.Key == transfer.TokenInfo.Symbol).Value)) : -(transfer.Amount * BigDecimal.FromDecimal((decimal)tokenPrices.First(t => t.Key == transfer.TokenInfo.Symbol).Value));
                       // Add the amount if user is receiving tokens (recipient is the user)
                       else if (transfer.ToAddress == info.Sender && tokenPrices.Any(t => t.Key == transfer.TokenInfo.Symbol))
                           pnlResult[info.Sender] = pnlResult.ContainsKey(info.Sender) ? pnlResult[info.Sender] + (transfer.Amount * BigDecimal.FromDecimal((decimal)tokenPrices.First(t => t.Key == transfer.TokenInfo.Symbol).Value)) : (transfer.Amount * BigDecimal.FromDecimal((decimal)tokenPrices.First(t => t.Key == transfer.TokenInfo.Symbol).Value));
                   }
               }

               // Subtract the fee from user's PNL if it exists
               if (info.Fee != null && tokenPrices.Any(t => t.Key == info.Fee.Symbol))
               {
                   var fee = info.Fee * BigDecimal.FromDecimal((decimal)tokenPrices.First(t => t.Key == info.Fee.Symbol).Value);
                   pnlResult[info.Sender] = pnlResult.ContainsKey(info.Sender) ? pnlResult[info.Sender] - fee : -fee;
               }

               // Return the PNL result as a CalculationResult object
               return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(pnlResult.Select(kv => new KeyValuePair<string, BigDecimal>(kv.Key, kv.Value)));
           }
       }
   }