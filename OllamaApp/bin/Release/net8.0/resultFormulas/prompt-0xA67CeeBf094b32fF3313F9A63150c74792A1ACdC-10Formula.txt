//Formula name is EXACTLY as function name in Solidity contract (even if it starts with a lowercase letter)
[assembly: FormulaAssembly("sync")]

namespace Sauron.Formula.Sync
{
    public class SyncFormula : IFormulaPlugin
    {
        //CalculationResult will ALWAYS be the same, so we follow the signature
        public CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?> Formula(TransactionInfo info,
            IEnumerable<KeyValuePair<string, decimal>>? tokenPrices = null)
        {
            //Check if transfers exist and there are at least 2 (for token0 and token1)
            if (info.Transfers == null || info.Transfers.Count < 2)
                return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(null);

            //Get the balances of token0 and token1 for this contract's address
            var token0Balance = info.Transfers.FirstOrDefault(t => t.TokenInfo.Symbol == "token0")?.Amount ?? 0;
            var token1Balance = info.Transfers.FirstOrDefault(t => t.TokenInfo.Symbol == "token1")?.Amount ?? 0;

            //Get the prices of tokens if provided, otherwise assume they are worth 1 unit each
            var priceOfToken0 = tokenPrices?.FirstOrDefault(p => p.Key == "token0").Value ?? 1m;
            var priceOfToken1 = tokenPrices?.FirstOrDefault(p => p.Key == "token1").Value ?? 1m;

            //Calculate the PNL for the contract's address, considering the balance and price of tokens
            var pnl = (token0Balance * new BigDecimal(priceOfToken0)) + (token1Balance * new BigDecimal(priceOfToken1));

            //Return the result as a list with one entry for the contract's address and its PNL
            return new CalculationResult<IEnumerable<KeyValuePair<string, BigDecimal>>?>(new List<KeyValuePair<string, BigDecimal>>()
            {
                new KeyValuePair<string, BigDecimal>(info.ToAddress, pnl)
            });
        }
    }
}